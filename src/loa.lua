--- OAuth2 Client Implementation.
-- OAuth 2.0 protocol implementation based on sanction (https://github.com/demianbrecht/sanction).
-- @module loa
-- @author Paul Lewis
-- @copyright 2014
-- @license MIT
-- @release 0.1.0
local h=require "ssl.https"
local l=require "ltn12"
local u=require "socket.url"
local j=require "json"
local loa={
    _options={},
    _default_parser=j.decode,
    _description="OAuth 2.0 protocol implementation based on sanction (https://github.com/demianbrecht/sanction).",
    _version="0.1.0"
}
loa.__index=loa

--- Create new OAuth2 client.
-- Returns a new OAuth2 client for use in authorizing a user against an OAuth2
-- authorization endpoint and requesting data from a relevent resource endpoint.
-- @tparam string auth_endpoint The Authorization URL. This endpoint will be
-- used to generate the authorization URI return by loa.auth_uri.
-- @tparam string token_endpoint The Token URL. This endpoint will be used to
-- to retrieve the authorization token when loa.request_token is called.
-- @tparam string resource_endpoint The resource endpoint. This URL will be used
-- when requesting resources from the provider.
-- @tparam string client_id The client ID given to you by the provider.
-- @tparam string client_secret the client secret given to you by the provider.
-- This should not be given to any one, ever.
-- @tparam[opt] function token_transport A function that will receive a url and
-- insert a token in the necessary manner in any http requests. Default is to
-- add "Authorization: Bearer {token}" to the HTTP headers. See the examples for
-- more info.
-- @treturn userdata The new loa client object.
function loa.new(auth_endpoint, token_endpoint, resource_endpoint, client_id, client_secret, token_transport)
    local o=setmetatable({}, loa)
    o.auth_endpoint    =auth_endpoint
    o.token_endpoint   =token_endpoint
    o.resource_endpoint=resource_endpoint
    o.client_id        =client_id
    o.client_secret    =client_secret
    o.access_token     =nil
    o.token_transport  =token_transport or loa._transport_headers
    o.token_expires    =-1
    o.refresh_token    =nil
    return o
end

--- Generate an authorization URI.
-- @param self
-- @tparam string redirect_uri The URL where the provider should return the user
-- after authentication. Usually this redirect will have the authorization
-- code that will be needed to retrieve an authorization token.
-- @tparam string scope A string containing the scopes that should be requested
-- from the provider. Typically comma or space delimitted.
-- @tparam[opt] string state The `state` parameter to pass for authorization. If
-- the provider follows the OAuth 2.0 spec, this will be returned to your
-- `redirect_uri` after authorization. Generally used for CSRF protection.
-- @tparam[opt] table options A table of any query paramaters that should be
-- included in the authorization URL. i.e.: ?auth_type=offline can be added to
-- the URI by providing this table: {auth_type="offline"}. All keys and values
-- in this table are automatically URL-Encoded.
-- @treturn string The generated authorization endpoint to where the user should
-- be directed to provide authorization.
function loa:auth_uri(redirect_uri, scope, state, options)
    options=options or {}
    options.client_id=self.client_id
    options.response_type="code"
    if scope then options.scope = scope end
    if state then options.state = state end
    if redirect_uri then options.redirect_uri=redirect_uri end
    local url_params = self._encode_params(options)
    return string.format("%s?%s", self.auth_endpoint, url_params)
end

--- Build an http request.
-- Construct an http request table to be provided to socket.http.request. Must
-- be called when providing a token_transport to loa.new.
-- @tparam string url The base url for the request.
-- @tparam[opt] table data A table representing the POST data of this request
-- (ifthere is any). i.e.: auth_type=offline can be added to the URI by
-- providing this table: {auth_type="offline"}. All keys and values in this
-- table are automatically URL-Encoded.
-- @tparam[opt] string method HTTP method to be used in the request. Defaults to
-- "GET" if data is nil, or "POST" if it is not.
-- @tparam[opt] table headers A table representing the headers to be included in
-- thisrequest. i.e.: "Content-Length: 8" can be included by providing this
-- table: {["Content-Length"]=8}. Note that Content-Length and Content-type will
-- be automatically provided if data is not nil.
-- @treturn table req A table to provide socket.http.request
-- @treturn table rsp A table that will hold the response generated by the
-- request.
function loa:build_request(url, data, method, headers)
    local req={}
    local rsp={}
    req.url=u.build(u.parse(url))
    data=data and self._encode_params(data) or nil
    req.source=data and l.source.string(data) or nil
    req.sink=l.sink.table(rsp)
    req.method=method or data and "POST" or "GET"
    req.headers=headers
    if headers then
        req.headers=headers
    elseif req.method=="POST" then
        req.headers={
            ["Content-Length"]=#data,
            ["Content-type"]  ="application/x-www-form-urlencoded"
        }
    end
    return req,rsp
end

--- Request an authorization token.
-- Sends a request to the token endpoint. After success, the token will be a
-- field of the loa object (access_token), and will be automatically included
-- in data requests via loa.request.
-- @param self
-- @tparam function parser A function that can parse the information returned
-- by the provider. This is typically json, though it varies by provider.
-- @tparam string redirect_uri Some providers require this parameter in a
-- request. You can include it as this argument or in the options table.
-- @tparam[opt] table options A table of any query paramaters that should be
-- included in the authorization URL. i.e.: ?auth_type=offline can be added to
-- the URI by providing this table: {auth_type="offline"}. All keys and values
-- in this table are automatically URL-Encoded.
-- @treturn boolean true if the http request was completed.
-- @treturn number the status code returned by the token endpoint.
-- @treturn table headers included in the response message.
-- @treturn string the full status code and message returned by the endpoint.
function loa:request_token(parser, redirect_uri, options)
    options=options or {}
    parser=parser or self._default_parser
    options.redirect_uri=options.redirect_uri or redirect_uri
    options.client_id=self.client_id
    options.client_secret=self.client_secret
    options.grant_type=options.grant_type or "authorization_code"
    local req,rsp =self:build_request(self.token_endpoint, options)
    local s,c,hdr,st=h.request(req)
    if not s then return end
    rsp=parser(table.concat(rsp))
    for k,v in pairs(rsp) do
        self[k]=v
    end
    if self.expires_in then
        self.token_expires=os.time()+self.expires_in
    end
    return s,c,hdr,st
end

--- Request data.
-- Requests and returns user data from the resource endpoint.
-- @param self
-- @tparam string url Appended to the end of the resource_endpoint.
-- @tparam[opt] string method HTTP method to be used in the request. Defaults to
-- "GET" if data is nil, or "POST" if it is not.
-- @tparam[opt] table data A table representing the POST data of this request
-- (ifthere is any). i.e.: auth_type=offline can be added to the URI by
-- providing this table: {auth_type="offline"}. All keys and values in this
-- table are automatically URL-Encoded.
-- @tparam[opt] table headers A table representing the headers to be included in
-- thisrequest. i.e.: "Content-Length: 8" can be included by providing this
-- table: {["Content-Length"]=8}. Note that Content-Length and Content-type will
-- be automatically provided if data is not nil.
-- @tparam[opt] function parser A function that can parse the information
-- returnedby the provider. This is typically json, though it varies by
-- provider.
function loa:request(url, method, data, headers, parser)
    if not self.access_token then return end
    parser=parser or self._default_parser
    method=method or data and "POST" or "GET"
    local req,rsp=self:token_transport(self.resource_endpoint .. url, self.access_token, data, method, headers)
    h.request(req)
    return parser(table.concat(rsp))
end

--- Refresh the authorization token.
-- After receiving an initial auth token, this function will send a refresh
-- token request.
-- @see loa.request_token
function loa:refresh(parser, options)
    options=options or {}
    if not options.refresh_token then
        options.refresh_token=self.refresh_token
    end
    if not options.grant_type then
        options.grant_type="refresh_token"
    end
    return self:request_token(parser, options)
end

--- Catch a redirect.
-- This is largely a helper function for if you are not actually running a
-- server. This will listen on a socket until it receives data, and then return
-- that data (likely an http request).
-- @tparam string redirect_uri The redirect URI provided in an earlier call to
-- loa.auth_uri.
-- @tparam[opt] string body An optional HTML document that will be returned upon
-- receiving the redirect. A default will be used if not provided.
-- @tparam[opt=2] number timeout Timeout value used for the server socket.
-- @tparam[opt=5] number hardtimeout If a redirect has not been received in this
-- many seconds. The function will return. Use math.huge to disable.
-- @treturn[1] string captured data.
-- @treturn[1] nil if an error.
-- @treturn[2] nil if no error.
-- @treturn[2] string error message.
function loa._catch_redirect(redirect_uri, body, timeout, hardtimeout)
    local response="HTTP/1.1 OK 200\nContent-Type: text/html;charset=utf-8\n"
        .. "Content-Length: %s\n\n%s"
    local data = ""

    timeout=timeout or 2
    hardtimeout=hardtimeout or 5
    redirect_uri=u.parse(redirect_uri)
    body=body or "<html><head><title>Thank You</title></head><body>You "
        .. "can close this window, now.\nThank You.</body></html>"

    local s=require 'socket'.tcp()
    s:bind(redirect_uri.host, tonumber(redirect_uri.port))
    s:listen(1)
    s:settimeout(timeout)

    local start=os.time()
    while os.time()-start<hardtimeout do
        c,e=s:accept()
        if c then
            c:settimeout(timeout)
            while true do
                local b,e=c:receive(1)
                if not b then break end
                data=data .. b
            end
            c:send(string.format(response, #body, body))
            c:close()
            s:close()
            return data
        end
    end
    return nil, "No Response received"
end

function loa._encode_params(params)
    local ue=u.escape
    local t={}
    for k,v in pairs(params) do
        table.insert(t, string.format("%s=%s", ue(k), ue(v)))
    end
    return table.concat(t, "&")
end

function loa:_transport_headers(url, access_token, data, method, headers)
    headers=headers or {}
    headers.Authorization="Bearer " .. (access_token or self.access_token)
    return self:build_request(url, data, method, headers)
end

function loa:_transport_query(url, access_token, data, method, headers)
    local parts=u.parse(url)
    parts.query=(parts.query or '') .. "access_token=" .. (access_token or self.access_token)
    url=u.build(parts)
    return self:build_request(url, data, method, headers)
end

return loa
